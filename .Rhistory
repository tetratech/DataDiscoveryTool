str(info)
i = info$row
j = info$col + 1
v = info$value
# Change Value "v" only IF column = 8 AND logical (T/F)
if(j==col.ApplyQAQC & (toupper(v)=="FALSE" | toupper(v)=="TRUE")) {
#if(j==col.ApplyQAQC) {
data_QAQC[i, j] <<- DT:::coerceValue(toupper(v), data_QAQC[i, j])
replaceData(proxy_dt_QAQC, data_QAQC, resetPaging = FALSE, rownames = FALSE)
# lose formatting of replaced table
}
})
}
)
runApp()
library(shiny)
library(DT)
shinyApp(
ui = fluidPage(
DT::dataTableOutput('x1')
),
server = function(input, output, session) {
x = iris
x$Date = Sys.time() + seq_len(nrow(x))
output$x1 = DT::renderDataTable(x, selection = 'none')
proxy = dataTableProxy('x1')
observeEvent(input$x1_cell_edit, {
info = input$x1_cell_edit
str(info)
i = info$row
j = info$col
v = info$value
x[i, j] <<- DT:::coerceValue(v, x[i, j])
replaceData(proxy, x, resetPaging = FALSE)
})
}
)
library(shiny)
library(DT)
library(XLConnect)
shinyApp(
ui = fluidPage(
DT::dataTableOutput('x1')
),
server = function(input, output, session) {
# QAQC Apply Column Settings
col.ApplyQAQC <- 8
color.ApplyQAQC <- 'yellow'
# table caption
myCaption <- "Double-click to edit a cell in column Apply.QAQC (highlighted in green [TRUE] or red [FALSE]).  Edits are only allowed in this column and only for the values TRUE and FALSE."
#
# load my File
# data_QAQC <-  DT::datatable(XLConnect::readWorksheetFromFile("external/DDT_QAQC_Default.xlsx"
#                                           , sheet="Methods Table"
#                                           , startRow=6
#                                           , header=TRUE
#                                           #, drop=c(13,14)
#                                           )
#                             , caption=myCaption
#                             , rownames=FALSE
#                             , selection='none'
#                             #, server=TRUE
#                             # ) %>% formatStyle(columns=col.ApplyQAQC
#                             #                   ,background=color.ApplyQAQC
#                             #                   ,fontWeight='bold')
#                             # Could potentially color cells based on content;
#                             # https://rstudio.github.io/DT/010-style.html
#                             # can't get working with column 8 and TRUE/FALSE
#                             ) %>% formatStyle(columns=8
#                                             , target="cell"
#                                             , background=styleEqual(c(1,0)
#                                                                     ,c('lightgreen','red'))
#                                             , fontWeight='bold'
#                                             )
#                             # #works on column 10 (units)
#                             # ) %>% formatStyle(columns=10
#                             #                 , target="cell"
#                             #                 , background=styleEqual(c("µg/L","mg/m2")
#                             #                                         ,c('lightgreen','red'))
#                             #                 )
data_QAQC <-  XLConnect::readWorksheetFromFile("external/DDT_QAQC_Default.xlsx"
, sheet="Methods Table"
, startRow=6
, header=TRUE
)
#x = data_QAQC
# have to do formating on datatable before render.  Render has reduced options.
# output$x1 = DT::renderDataTable(data_QAQC
#                                  , server=TRUE
#                                 #, selection = list(target="column",selected=7)
#                                 #, rownames = FALSE
#                                 #, caption = myCaption
#                                 # , options = list(
#                                             # , formatStyle(columns=8
#                                             #             #, target="column"
#                                             #             , background="yellow")
#                                             # #)
#                                 )
output$x1 = DT::renderDataTable(DT::datatable(data_QAQC
, caption=myCaption
, rownames=FALSE
, selection='none'
) %>% formatStyle(columns=8
, target="cell"
, background=styleEqual(c(1,0)
,c('lightgreen','red'))
, fontWeight='bold'
)
)
# %>% formatStyle(8,background='yellow')
#formatStyle(table="x1",columns="apply", backgroundColor='blue', fontWeight = 'bold')
#, searchHighlight=TRUE
proxy_dt_QAQC = dataTableProxy('x1')
observeEvent(input$x1_cell_edit, {
info = input$x1_cell_edit
str(info)
i = info$row
j = info$col + 1
v = info$value
# Change Value "v" only IF column = 8 AND logical (T/F)
if(j==col.ApplyQAQC & (toupper(v)=="FALSE" | toupper(v)=="TRUE")) {
#if(j==col.ApplyQAQC) {
data_QAQC[i, j] <<- DT:::coerceValue(toupper(v), data_QAQC[i, j])
replaceData(proxy_dt_QAQC, data_QAQC, resetPaging = FALSE, rownames = FALSE)
# lose formatting of replaced table
}
})
}
)
library(shiny)
library(DT)
library(XLConnect)
shinyApp(
ui = fluidPage(
DT::dataTableOutput('x1')
),
server = function(input, output, session) {
# QAQC Apply Column Settings
col.ApplyQAQC <- 8
color.ApplyQAQC <- 'yellow'
# table caption
myCaption <- "Double-click to edit a cell in column Apply.QAQC (highlighted in green [TRUE] or red [FALSE]).  Edits are only allowed in this column and only for the values TRUE and FALSE."
#
# load my File
# data_QAQC <-  DT::datatable(XLConnect::readWorksheetFromFile("external/DDT_QAQC_Default.xlsx"
#                                           , sheet="Methods Table"
#                                           , startRow=6
#                                           , header=TRUE
#                                           #, drop=c(13,14)
#                                           )
#                             , caption=myCaption
#                             , rownames=FALSE
#                             , selection='none'
#                             #, server=TRUE
#                             # ) %>% formatStyle(columns=col.ApplyQAQC
#                             #                   ,background=color.ApplyQAQC
#                             #                   ,fontWeight='bold')
#                             # Could potentially color cells based on content;
#                             # https://rstudio.github.io/DT/010-style.html
#                             # can't get working with column 8 and TRUE/FALSE
#                             ) %>% formatStyle(columns=8
#                                             , target="cell"
#                                             , background=styleEqual(c(1,0)
#                                                                     ,c('lightgreen','red'))
#                                             , fontWeight='bold'
#                                             )
#                             # #works on column 10 (units)
#                             # ) %>% formatStyle(columns=10
#                             #                 , target="cell"
#                             #                 , background=styleEqual(c("µg/L","mg/m2")
#                             #                                         ,c('lightgreen','red'))
#                             #                 )
data_QAQC <-  XLConnect::readWorksheetFromFile("external/DDT_QAQC_Default.xlsx"
, sheet="Methods Table"
, startRow=6
, header=TRUE
)
#x = data_QAQC
# have to do formating on datatable before render.  Render has reduced options.
# output$x1 = DT::renderDataTable(data_QAQC
#                                  , server=TRUE
#                                 #, selection = list(target="column",selected=7)
#                                 #, rownames = FALSE
#                                 #, caption = myCaption
#                                 # , options = list(
#                                             # , formatStyle(columns=8
#                                             #             #, target="column"
#                                             #             , background="yellow")
#                                             # #)
#                                 )
output$x1 = DT::renderDataTable(DT::datatable(data_QAQC
, caption=myCaption
, rownames=FALSE
, selection='none'
)
# %>% formatStyle(columns=8
#                     , target="cell"
#                     , background=styleEqual(c(1,0)
#                                             ,c('lightgreen','red'))
#                     , fontWeight='bold'
#                     )
#
)
# %>% formatStyle(8,background='yellow')
#formatStyle(table="x1",columns="apply", backgroundColor='blue', fontWeight = 'bold')
#, searchHighlight=TRUE
proxy_dt_QAQC = dataTableProxy('x1')
observeEvent(input$x1_cell_edit, {
info = input$x1_cell_edit
str(info)
i = info$row
j = info$col + 1
v = info$value
# Change Value "v" only IF column = 8 AND logical (T/F)
if(j==col.ApplyQAQC & (toupper(v)=="FALSE" | toupper(v)=="TRUE")) {
#if(j==col.ApplyQAQC) {
data_QAQC[i, j] <<- DT:::coerceValue(toupper(v), data_QAQC[i, j])
replaceData(proxy_dt_QAQC, data_QAQC, resetPaging = FALSE, rownames = FALSE)
# lose formatting of replaced table
}
})
}
)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
library(shiny)
library(DT)
library(XLConnect)
shinyApp(
ui = fluidPage(
DT::dataTableOutput('x1')
),
server = function(input, output, session) {
# load my File
data_QAQC <- XLConnect::readWorksheetFromFile("external/DDT_QAQC_Default.xlsx"
, sheet="Methods Table", startRow=6, header=TRUE)
#x = data_QAQC
myCaption <- "Double-click to edit a cell.  'TRUE' and 'FALSE' are the only values allowed.  And only for column 'apply'."
output$x1 = DT::renderDataTable(data_QAQC, server=TRUE, selection = 'none', rownames = FALSE
, caption = myCaption)
#formatStyle(table="x1",columns="apply", backgroundColor='blue', fontWeight = 'bold')
proxy_dt_QAQC = dataTableProxy('x1')
observeEvent(input$x1_cell_edit, {
info = input$x1_cell_edit
str(info)
i = info$row
j = info$col + 1
v = info$value
# Change Value "v" only IF column = 8 AND logical (T/F)
if(j==8 & (toupper(v)=="FALSE" | toupper(v)=="TRUE")) {
data_QAQC[i, j] <<- DT:::coerceValue(toupper(v), data_QAQC[i, j])
replaceData(proxy_dt_QAQC, data_QAQC, resetPaging = FALSE, rownames = FALSE)
}
})
}
)
library(shiny)
library(DT)
library(XLConnect)
shinyApp(
ui = fluidPage(
fluidRow(column(3, downloadButton("SaveQAQC","Save QAQC File"))
, bsPopover("SaveQAQC", "Save QAQC", "Click to save an .XLSX file containing the QAQC decisions.",
"top", trigger = "hover", options = list(container = "body"))
)
,DT::dataTableOutput('x1')
),
server = function(input, output, session) {
# load my File
data_QAQC <- XLConnect::readWorksheetFromFile("external/DDT_QAQC_Default.xlsx"
, sheet="Methods Table", startRow=6, header=TRUE)
#x = data_QAQC
myCaption <- "Double-click to edit a cell.  'TRUE' and 'FALSE' are the only values allowed.  And only for column 'apply'."
output$x1 = DT::renderDataTable(data_QAQC, server=TRUE, selection = 'none', rownames = FALSE
, caption = myCaption)
#formatStyle(table="x1",columns="apply", backgroundColor='blue', fontWeight = 'bold')
proxy_dt_QAQC = dataTableProxy('x1')
observeEvent(input$x1_cell_edit, {
info = input$x1_cell_edit
str(info)
i = info$row
j = info$col + 1
v = info$value
# Change Value "v" only IF column = 8 AND logical (T/F)
if(j==8 & (toupper(v)=="FALSE" | toupper(v)=="TRUE")) {
data_QAQC[i, j] <<- DT:::coerceValue(toupper(v), data_QAQC[i, j])
replaceData(proxy_dt_QAQC, data_QAQC, resetPaging = FALSE, rownames = FALSE)
}
})
}
)
#devtools::install_github('rstudio/DT@feature/editor') # only need to install once
library(shiny)
library(DT)
library(XLConnect)
shinyApp(
ui = fluidPage(
fluidRow(column(3, downloadButton("SaveQAQC","Save QAQC File"))
, bsPopover("SaveQAQC", "Save QAQC", "Click to save an .XLSX file containing the QAQC decisions.",
"top", trigger = "hover", options = list(container = "body"))
)
,DT::dataTableOutput('x1')
),
server = function(input, output, session) {
## Save QAQC
output$SaveQAQC <- downloadHandler(
filename = function() {
strFile <- paste0("DDT_QAQC_",format(Sys.time(),"%Y%m%d_%H%M%S"),".xlsx")}
, content = function(file) {
#
# Copy BLANK XLSX
file.copy(from="external/DDT_QAQC_BLANK.xlsx"
, to=file)
# Then copy in data
mySheet <- "Methods Table"
wb <- XLConnect::loadWorkbook(file)
XLConnect::writeWorksheet(wb, data=data_QAQC, sheet=mySheet, startRow=7, header=FALSE)
XLConnect::saveWorkbook(wb)
#
}
)
# load my File
data_QAQC <- XLConnect::readWorksheetFromFile("external/DDT_QAQC_Default.xlsx"
, sheet="Methods Table", startRow=6, header=TRUE)
#x = data_QAQC
myCaption <- "Double-click to edit a cell.  'TRUE' and 'FALSE' are the only values allowed.  And only for column 'apply'."
output$x1 = DT::renderDataTable(data_QAQC, server=TRUE, selection = 'none', rownames = FALSE
, caption = myCaption)
#formatStyle(table="x1",columns="apply", backgroundColor='blue', fontWeight = 'bold')
proxy_dt_QAQC = dataTableProxy('x1')
observeEvent(input$x1_cell_edit, {
info = input$x1_cell_edit
str(info)
i = info$row
j = info$col + 1
v = info$value
# Change Value "v" only IF column = 8 AND logical (T/F)
if(j==8 & (toupper(v)=="FALSE" | toupper(v)=="TRUE")) {
data_QAQC[i, j] <<- DT:::coerceValue(toupper(v), data_QAQC[i, j])
replaceData(proxy_dt_QAQC, data_QAQC, resetPaging = FALSE, rownames = FALSE)
}
})
}
)
36+45/60+1.97/3600
108+24/60+53.85/3600
36+46/60+53.78/3600
108+41/60+35.48/3600
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
myData <- all_data()
myFields <- c("ActivityMediaName", "CharacteristicName", "ResultSampleFractionText"
, "USGSPCode", "Unit", "Result")
# subset to desired fields
myData4QAQC <- myData[,myFields]
# summarize with dplyr
myData.QAQC.Summary <- myData4QAQC %>%
group_by(ActivityMediaName, CharacteristicName, ResultSampleFractionText, USGSPCode, Unit) %>%
summarise(n=n(),minObs=min(Result,na.rm=TRUE),maxObs=max(Result,na.rm=TRUE))
# match with QAQC Decisions
# x <- merge(myData.QAQC.Summary, data_QAQC[c(myFields, "Apply.QAQC")], by=myFields, all.x=TRUE)
dim(data_QAQC)
x <- merge(myData.QAQC.Summary, data_QAQC[c(myFields, "Apply.QAQC")], by=myFields, all.x=TRUE)
myFields %in% names(myData.QAQC.Summary)
myFields <- c("ActivityMediaName", "CharacteristicName", "ResultSampleFractionText"
, "USGSPCode", "Unit", "Result")
myData <- all_data()
# define desired fields
myFields <- c("ActivityMediaName", "CharacteristicName", "ResultSampleFractionText"
, "USGSPCode", "Unit", "Result")
# subset to desired fields
myData4QAQC <- myData[,myFields]
# summarize with dplyr
myData.QAQC.Summary <- myData4QAQC %>%
group_by(ActivityMediaName, CharacteristicName, ResultSampleFractionText, USGSPCode, Unit) %>%
summarise(n=n(),minObs=min(Result,na.rm=TRUE),maxObs=max(Result,na.rm=TRUE))
# match with QAQC Decisions
myData <- all_data()
runApp()
myData <- all_data()
# define desired fields
myFields <- c("ActivityMediaName", "CharacteristicName", "ResultSampleFractionText"
, "USGSPCode", "Unit", "Result")
# subset to desired fields
myData4QAQC <- myData[,myFields]
# summarize with dplyr
myData.QAQC.Summary <- myData4QAQC %>%
group_by(ActivityMediaName, CharacteristicName, ResultSampleFractionText, USGSPCode, Unit) %>%
summarise(n=n(),minObs=min(Result,na.rm=TRUE),maxObs=max(Result,na.rm=TRUE))
# match with QAQC Decisions
dim(data_QAQC)
myFields
myFields %in% names(data_QAQC)
names(data_QAQC)
myFields.data_QAQC <- c("Activity.Media", "Characteristic", "Sample.Fraction"
, "PCODE", "Units")
data_QAQC_temp <- data_QAQC
data_QAQC_temp$MatchQAQC <- TRUE
View(data_QAQC_temp)
myFields[1:5]
myFields.data_QAQC
x <- merge(myData.QAQC.Summary, data_QAQC_temp[,myFields.data_QAQC]
, by.x=myFields[1:5], by.y=myFields.data_QAQC
, all.x=TRUE)
View(x)
x <- merge(myData.QAQC.Summary, data_QAQC_temp[,c(myFields.data_QAQC,"MatchQAQC")]
, by.x=myFields[1:5], by.y=myFields.data_QAQC
, all.x=TRUE)
View(x)
dim(x)
dim(data_QAQC_temp)
dim(myData.QAQC.Summary)
x$MatchQAQC[is.na(x$MatchQAQC)] <- FALSE
View(x)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
dim(RV_QAQC$df_data)
dim(QAQC_combos_data())
a <- names(QAQC_combos_data())
b <- names(RV_QAQC$df_data)
a
b
a <- names(RV_QAQC$df_data)
b <- names(QAQC_combos_data())
a
b
df.add <- QAQC_combos_data()
df.add[,"MatchQAQC"]==FALSE
df.add <- df.add[df.add[,"MatchQAQC"]==FALSE,]
dim(df.add)
df.add <- QAQC_combos_data()
# 1.2. Filter for new records and only matching columns
df.add <- df.add[df.add[,"MatchQAQC"]==FALSE,c(1:5)]
dim(df.add)
df.merge <- rbind(RV_QAQC$df_data,df.add)
dplyr::bind_rows(RV_QAQC$df_data, df.add)
df.merge <- dplyr::bind_rows(RV_QAQC$df_data,df.add)
a <- names(RV_QAQC$df_data)
runApp()
a <- names(RV_QAQC$df_data)
b <- names(QAQC_combos_data())
a
b
df.add <- QAQC_combos_data()
dim(df.add)
df.add <- df.add[df.add[,"MatchQAQC"]==FALSE,c(1:5)]
dim(df.add)
df.merge <- dplyr::bind_rows(RV_QAQC$df_data,df.add)
dim(df.merge)
RV_QAQC$df_data <- df.merge
DT::replaceData(proxy_dt_QAQC, RV_QAQC$df_data, resetPaging=TRUE, rownames=FALSE)
runApp()
runApp()
runApp()
runApp()
df.merge <- merge(RV_QAQC$df_data, df.add
, by.x=names(RV_QAQC$df_data)[1:5]
, by.y=names(df.add)[1:5]
, all.x=TRUE)
dim(df.merge)
names(RV_QAQC$df_data)
names(df.add)
runApp()
dim(df.add)
df.add[,6:9] <-NA
dim(df.add)
df.add[,6:9] <- NA
names(df.add) <- names(RV_QAQC$df_data)
# 1.4. ApplyQAQC column to FALSE
df.add[,"Apply.QAQC"] <- FALSE
runApp()
